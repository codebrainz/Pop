#ifndef POP_AST_HPP
#define POP_AST_HPP

#include <Pop/Operators.hpp>
#include <Pop/SymbolTable.hpp>
#include <Pop/Transformer.hpp>
#include <Pop/Visitor.hpp>
#include <string>
#include <vector>

namespace Pop {

  struct Node;
  typedef std::vector<Node*> NodeVector;

  struct Location {
    const char *file;
    int line, column;
    Location(const char *file="", int line=-1, int column=-1)
      : file(file), line(line), column(column) {
    }
  };

  struct Node {
    Node *parent;
    SymbolTable *enclosing_scope;
    Node(const Node&) = delete;
    Node(Node&&) = delete;
    Node& operator=(const Node&) = delete;
    Node& operator=(Node&&) = delete;
    virtual ~Node() {
    }
    const char *file() const { return location.file?location.file:""; }
    void file(const char *f) { location.file = f?f:""; }
    int line() const { return location.line; }
    void line(int l) { location.line = l; }
    int column() const { return location.column; }
    void column(int c) { location.column = c; }
    Node *ref() {
      ref_count++;
      return this;
    }
    Node *unref() {
      ref_count--;
      if (ref_count == 0) {
        delete this;
        return nullptr;
      }
      return this;
    }
    virtual void accept(VisitorBase&) = 0;
    virtual Node *transform(TransformerBase&) = 0;
    virtual const std::string &type_name() const = 0;
  protected:
    Node(const char *fn="", int line=-1, int column=-1)
      : parent(nullptr), enclosing_scope(nullptr), ref_count(1), location(fn, line, column) {
    }
  private:
    unsigned long long int ref_count;
    Location location;
  };

  template< class T >
  inline T *node_ref(T *n) {
    if (n)
      return static_cast<T*>(n->ref());
    return nullptr;
  }

  template< class T >
  inline T *node_unref(T *n) {
    if (n)
      return static_cast<T*>(n->unref());
    return nullptr;
  }

  struct NodeList final : public Node {
    NodeVector elements;
    NodeList(const NodeList&) = delete;
    NodeList(NodeList&&) = delete;
    NodeList& operator=(const NodeList&) = delete;
    NodeList& operator=(NodeList&&) = delete;
    NodeList(const char *fn="", int line=-1, int column=-1)
      : Node(fn, line, column) {
    }
    NodeList(const char *fn, int line, int column, Node *first)
      : Node(fn, line, column) {
      append_take(first);
    }
    ~NodeList() override final {
      for (auto child : elements)
        node_unref(child);
    }
    void append_take(Node *n) {
      elements.push_back(n);
    }
    void append(Node *n) {
      append_take(node_ref(n));
    }
    void accept(VisitorBase &v) override final {
      v.visit(*this);
    }
    Node *transform(TransformerBase &t) override final {
      return t.transform(this);
    }
    const std::string &type_name() const override final {
      static const std::string s = "NodeList";
      return s;
    }
  };
{% for node in nodes %}
  struct {{ node.name }} final : public Node {
  {%- for field in node.fields %}
    {{ field.type }} {{ field.name }};
  {%- endfor %}
  {{ node.name }}(const {{ node.name }}&) = delete;
  {{ node.name }}({{ node.name }}&&) = delete;
  {{ node.name }}& operator=(const {{ node.name }}&) = delete;
  {{ node.name }}& operator=({{ node.name }}&&) = delete;
  {{ node.name }}(const char *fn="", int line=-1, int column=-1)
    : Node(fn, line, column) {
  }
  {%- if node.construct_fields | length > 0 %}
  {{ node.name }}(const char *fn, int line, int column, {% for field in node.construct_fields %}{{ field.type }} {{ field.name }}{% if loop.index < node.construct_fields | length %}, {% endif %}{% endfor %})
    : Node(fn, line, column), {% for field in node.construct_fields %}{{ field.name }}({{ field.name }}){% if loop.index < node.construct_fields | length %}, {% endif %}{% endfor %} {
  }
  {{ node.name }}({% for field in node.construct_fields %}{{ field.type }} {{ field.name }}{% if loop.index < node.construct_fields | length %}, {% endif %}{% endfor %})
    : Node(nullptr, -1, -1), {% for field in node.construct_fields %}{{ field.name }}({{ field.name }}){% if loop.index < node.construct_fields | length %}, {% endif %}{% endfor %} {
  }
  {%- endif %}
  {%- if node.child_fields | length > 0 %}
    ~{{ node.name }}() override final {
    {%- for field in node.child_fields %}
      node_unref({{ field.name }});
    {%- endfor %}
    }
  {%- endif %}
    void accept(VisitorBase &v) override final {
      v.visit(*this);
    }
    Node *transform(TransformerBase &t) override final {
      return t.transform(this);
    }
    const std::string &type_name() const override final {
      static const std::string s = "{{ node.name }}";
      return s;
    }
  };
{% endfor %}

  template<class T, class... Args>
  inline T* make_node(Args&& ...args) {
    return new T(std::forward<Args>(args)...);
  }
}

#endif // POP_AST_HPP
