#ifndef POP_INSTRUCTIONS_HPP
#define POP_INSTRUCTIONS_HPP

#include <Pop/AST.hpp>
#include <cstdint>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace Pop {

{% for instruction in instructions -%}
  struct {{ instruction.name }}Instruction;
{%- endfor %}

  enum class OpCode : std::uint8_t {
{%- for instruction in instructions %}
    {{ instruction.mnemonic }},
{%- endfor %}
  };

  class Instruction {
  public:
    int offset;

    virtual ~Instruction() {
      node_unref(ast_node);
    }
    virtual OpCode op_code() const = 0;
    virtual const std::string &mnemonic() const = 0;
    virtual int size() const = 0;
    const char *file() const {
      if (ast_node)
        return ast_node->file();
      return nullptr;
    }
    int line() const {
      if (ast_node)
        return ast_node->line();
      return -1;
    }
    int column() const {
      if (ast_node)
        return ast_node->column();
      return -1;
    }
    template< class T >
    T *checked_cast() {
      return dynamic_cast<T*>(this);
    }

  protected:
    Node *ast_node;
    Instruction(Node *ast_node) : offset(-1), ast_node(node_ref(ast_node)) {
    }
  };

  typedef std::unique_ptr<Instruction> InstructionPtr;
  typedef std::vector<InstructionPtr> InstructionList;

{% for instruction in instructions %}
  struct {{ instruction.name }}Instruction final : public Instruction {
  {%- for field in instruction.fields %}
    {{ field.type }} {{ field.name }};
  {%- endfor %}
    {{ instruction.name }}Instruction(
    {%- if instruction.construct_fields | length > 0 -%}
      {%- for field in instruction.construct_fields -%}
        {{ field.type }} {{ field.name }},
      {%- endfor -%}
    {%- endif -%} Node* ast_node=nullptr)
      : Instruction(ast_node)
    {%- for field in instruction.fields -%}
      {%- if field.construct %}
        {%- if field.type == "std::string" -%}
          ,{{ field.name }}(std::move({{ field.name }}))
        {%- elif field.type == "Node*" -%}
          ,{{ field.name }}(node_ref({{ field.name }}))
        {%- else -%}
          ,{{ field.name }}({{ field.name }})
        {%- endif -%}
      {%- elif field.default is not none %}
        ,{{ field.name }}({{ field.default }})
      {%- endif %}
    {%- endfor %} {
    }
  {%- if instruction.node_fields | length > 0 %}
    ~{{ instruction.name }}Instruction() final {
    {%- for field in instruction.node_fields %}
      node_unref({{ field.name }});
    {%- endfor %}
    }
  {%- endif %}
    OpCode op_code() const final {
      return OpCode::{{ instruction.mnemonic }};
    }
    const std::string &mnemonic() const final {
      static const std::string mn = "{{ instruction.mnemonic }}";
      return mn;
    }
    int size() const final {
      return {{ instruction.size }};
    }
  };
{% endfor %}

  void resolve_instructions(InstructionList &instructions);
  void optimize_instructions(InstructionList &instructions);

  class ConstantsTable;
  void dump_instructions(const InstructionList &instructions,
      ConstantsTable &const_tab, std::ostream &os);

// namespace Pop
}

#endif // POP_INSTRUCTIONS_HPP
