#ifndef POP_INSTRUCTIONS_HPP
#define POP_INSTRUCTIONS_HPP

#include <Pop/AST.hpp>
#include <Pop/InstructionList.hpp>
#include <Pop/InstructionVisitor.hpp>
#include <Pop/TypeInfo.hpp>
#include <cstdint>
#include <istream>
#include <memory>
#include <ostream>
#include <string>
#include <vector>

namespace Pop {

  enum class OpCode : std::uint8_t {
{%- for instruction in instructions %}
    {{ instruction.mnemonic }},
{%- endfor %}
  };

  class Instruction;
  typedef std::unique_ptr<Instruction> InstructionPtr;

  class Instruction {
  public:
    OpCode code;
    int offset;

    virtual ~Instruction() {
      node_unref(ast_node);
    }
    virtual const std::string &mnemonic() const = 0;
    virtual int size() const = 0;
    virtual void accept(InstructionVisitor&) = 0;
    const char *file() const {
      if (ast_node)
        return ast_node->file();
      return nullptr;
    }
    int line() const {
      if (ast_node)
        return ast_node->line();
      return -1;
    }
    int column() const {
      if (ast_node)
        return ast_node->column();
      return -1;
    }

    virtual std::string to_string() const;
    virtual void serialize(std::ostream &os) const;
    static InstructionPtr deserialize(std::istream &is);

  protected:
    Node *ast_node;
    Instruction(OpCode oc, Node *ast_node)
      : code(oc), offset(-1), ast_node(node_ref(ast_node)) {
    }
  };

{% for instruction in instructions %}
  struct {{ instruction.name }}Instruction final : public Instruction {
  {%- for field in instruction.fields %}
    {{ field.type }} {{ field.name }};
  {%- endfor %}
    {{ instruction.name }}Instruction(
    {%- if instruction.construct_fields | length > 0 -%}
      {%- for field in instruction.construct_fields -%}
        {{ field.type }} {{ field.name }},
      {%- endfor -%}
    {%- endif -%} Node* ast_node=nullptr)
      : Instruction(OpCode::{{ instruction.mnemonic }}, ast_node)
    {%- for field in instruction.fields -%}
      {%- if field.construct %}
        {%- if field.type == "std::string" -%}
          ,{{ field.name }}(std::move({{ field.name }}))
        {%- elif field.type == "Node*" -%}
          ,{{ field.name }}(node_ref({{ field.name }}))
        {%- else -%}
          ,{{ field.name }}({{ field.name }})
        {%- endif -%}
      {%- elif field.default is not none %}
        ,{{ field.name }}({{ field.default }})
      {%- endif %}
    {%- endfor %} {
    }
  {%- if instruction.node_fields | length > 0 %}
    ~{{ instruction.name }}Instruction() final {
    {%- for field in instruction.node_fields %}
      node_unref({{ field.name }});
    {%- endfor %}
    }
  {%- endif %}
    const std::string &mnemonic() const final {
      static const std::string mn = "{{ instruction.mnemonic }}";
      return mn;
    }
    int size() const final {
      return {{ instruction.size }};
    }
    void accept(InstructionVisitor &v) final {
      v.visit(*this);
    }
  {%- if instruction.name in ["Jump", "JumpIfTrue", "JumpIfFalse", "Closure" ] %}
    std::string to_string() const final;
    void serialize(std::ostream &os) const final;
  {%- elif instruction.name in ["PushConst"] %}
    std::string to_string() const final;
    void serialize(std::ostream &os) const final;
  {%- elif instruction.name in ["Label"] %}
    std::string to_string() const final;
  {%- endif %}
    static bool classof(const Instruction *n) {
      return (n->code == OpCode::{{ instruction.mnemonic }});
    }
  };
{% endfor %}

  void optimize_instructions(InstructionList &instructions);

  class ConstantsTable;
  void dump_instructions(const InstructionList &instructions,
      ConstantsTable &const_tab, std::ostream &os);

// namespace Pop
}

#endif // POP_INSTRUCTIONS_HPP
