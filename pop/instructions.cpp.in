#ifdef HAVE_CONFIG_H
#include <pop/config.h>
#endif

#include <pop/instructions.hpp>
#include <pop/serialization.hpp>
#include <pop/type-code.hpp>

#include <cassert>
#include <cstring>
#include <sstream>

namespace Pop {

  std::string Instruction::to_string() const {
    std::stringstream ss;
    ss << '\t' << mnemonic() << '\n';
    return ss.str();
  }

  void Instruction::serialize(std::ostream &os) const {
    serialize8(os, code);
  }
{% for instruction in instructions %}
  {%- if instruction.name in ["Jump", "JumpIfTrue", "JumpIfFalse", "Closure" ] %}
  std::string {{ instruction.name }}Instruction::to_string() const {
    std::stringstream ss;
    char buf[32] = {0};
    std::snprintf(buf, 31, "%04XH", target);
    ss << '\t' << mnemonic() << ' ' << buf << '\n';
    return ss.str();
  }

  void {{ instruction.name }}Instruction::serialize(std::ostream &os) const {
    Instruction::serialize(os);
    serialize32(os, target);
  }
  {%- elif instruction.name in ["PushConst"] %}
  std::string {{ instruction.name }}Instruction::to_string() const {
    std::stringstream ss;
    ss << '\t' << mnemonic() << ' ' << const_id << '\n';
    return ss.str();
  }

  void {{ instruction.name }}Instruction::serialize(std::ostream &os) const {
    Instruction::serialize(os);
    serialize32(os, const_id);
  }
  {%- elif instruction.name in ["Label"] %}
  void {{ instruction.name }}Instruction::serialize(std::ostream&) const {
    assert(false);
  }

  std::string {{ instruction.name }}Instruction::to_string() const {
    std::stringstream ss;
    ss << name << ":\n";
    return ss.str();
  }
  {%- elif instruction.name in ["Comment"] %}
  void {{ instruction.name }}Instruction::serialize(std::ostream&) const {
    assert(false);
  }

  std::string {{ instruction.name }}Instruction::to_string() const {
    std::stringstream ss;
    ss << "; " << text << '\n';
    return ss.str();
  }
  {%- elif instruction.name in ["Line"] %}
  void {{ instruction.name }}Instruction::serialize(std::ostream&) const {
    assert(false);
  }

  std::string {{ instruction.name }}Instruction::to_string() const {
    if (file.empty() && line < 0)
      return "";
    std::stringstream ss;
    ss << "#line";
    if (!file.empty())
      ss << " \"" << file << "\"";
    if (line >= 0) {
      ss << ' ' << line;
      if (column >= 0)
        ss << ' ' << column;
    }
    ss << '\n';
    return ss.str();
  }
  {%- endif %}
{% endfor %}

  InstructionPtr Instruction::deserialize(std::istream &is) {
    InstructionPtr result;
    auto code = static_cast<OpCode>(deserialize8(is));
    switch (code) {
{%- for instruction in instructions %}
  {%- if instruction.name in [ "Jump", "JumpIfTrue", "JumpIfFalse", "Closure" ] %}
      case OpCode::{{ instruction.mnemonic }}: {
        auto offset = is.tellg();
        auto inst = std::make_unique<{{ instruction.name }}Instruction>("");
        inst->target = deserialize32(is);
        inst->offset = offset;
        result = std::move(inst);
        break;
      }
  {%- elif instruction.name in [ "PushConst" ] %}
      case OpCode::{{ instruction.mnemonic }}: {
        auto offset = is.tellg();
        auto inst = std::make_unique<{{ instruction.name }}Instruction>(deserialize32(is));
        inst->offset = offset;
        result = std::move(inst);
        break;
      }
  {%- elif instruction.name in [ "Label" ] %}
      case OpCode::{{ instruction.mnemonic }}: {
        assert(false);
        break;
      }
  {%- elif instruction.name in [ "Comment" ] %}
      case OpCode::{{ instruction.mnemonic }}: {
        assert(false);
        break;
      }
  {%- elif instruction.name in [ "Line" ] %}
      case OpCode::{{ instruction.mnemonic }}: {
        assert(false);
        break;
      }
  {%- else %}
      case OpCode::{{ instruction.mnemonic }}: {
        auto offset = is.tellg();
        auto inst = std::make_unique<{{ instruction.name }}Instruction>();
        inst->offset = offset;
        result = std::move(inst);
        break;
      }
  {%- endif %}
{%- endfor %}
    }
    return result;
  }

// namespace Pop
}
